<head>
  <script>
    //  6kyu
    //  Stop gninnipS My sdroW!

    //  Write a function that takes in a string of one or more words, and
    //  returns the same string, but with all five or more letter words
    //  reversed (Just like the name of this Kata). Strings passed in will
    //  consist of only letters and spaces. Spaces will be included only
    //  when more than one word is present.

    // Examples:

    // spinWords( "Hey fellow warriors" ) => returns "Hey wollef sroirraw"
    // spinWords( "This is a test") => returns "This is a test"
    // spinWords( "This is another test" )=> returns "This is rehtona test"

    function spinWords(string) {
      let splittedWord = string.split(" ");
      var result = [];
      for (word of splittedWord) {
        if (word.length >= 5) {
          result.push(word.split("").reverse().join(""));
        } else result.push(word);
      }
      result = result.toString();
      let resultWithSpaces = result.replace(/,/g, " ");
      return resultWithSpaces;
    }

    // console.log(spinWords("Welcome saas sa 123556"));

    // ==============================================================================================

    // 6kyu
    // Find the odd int

    // Given an array of integers, find the one that appears an odd number of times.

    // There will always be only one integer that appears an odd number of times.
    // Examples

    // [7] should return 7, because it occurs 1 time (which is odd).
    // [0] should return 0, because it occurs 1 time (which is odd).
    // [1,1,2] should return 2, because it occurs 1 time (which is odd).
    // [0,1,0,1,0] should return 0, because it occurs 3 times (which is odd).
    // [1,2,2,3,3,3,4,3,3,3,2,2,1] should return 4, because it appears 1 time (which is odd).

    function findOdd(A) {
      let digitCollection = [];
      for (digit of A) {
        if (!digitCollection.includes(digit)) digitCollection.push(digit);
      }
      for (digit of digitCollection) {
        let counter = 0;
        for (item of A) {
          if (digit === item) counter++;
        }
        if (counter % 2 === 1) return digit;
      }
      return 0;
    }
    // findOdd([6, 2, 2, 2, 2]);

    // =====================================================================================

    // 6 kyu
    // Sum of Digits / Digital Root

    // Digital root is the recursive sum of all the digits in a number.

    // Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. The input will be a non-negative integer.
    // Examples
    //
    // 16  -->  1 + 6 = 7
    //  942  -->  9 + 4 + 2 = 15  -->  1 + 5 = 6
    // 132189  -->  1 + 3 + 2 + 1 + 8 + 9 = 24  -->  2 + 4 = 6
    // 493193  -->  4 + 9 + 3 + 1 + 9 + 3 = 29  -->  2 + 9 = 11  -->  1 + 1 = 2

    function digitalRoot(n) {
      if (n < 10) return n;

      return digitalRoot(
        n
          .toString()
          .split("")
          .reduce((acc, d) => {
            return acc + +d;
          }, 0)
      );
    }

    // digitalRoot(456);
    //==================================================================================

    // 6 kyu
    // Two Sum
    // Write a function that takes an array of numbers (integers for the tests) and a target number. It should find two different items in the array that, when added together, give the target value. The indices of these items should then be returned in a tuple / list (depending on your language) like so: (index1, index2).

    // For the purposes of this kata, some tests may have multiple answers; any valid solutions will be accepted.

    // The input will always be valid (numbers will be an array of length 2 or greater, and all of the items will be numbers; target will always be the sum of two different items from that array).

    // Based on: http://oj.leetcode.com/problems/two-sum/

    // twoSum([1, 2, 3], 4) // returns [0, 2] or [2, 0]

    function twoSum(nums, target) {
      let result1 = 0;
      let result2 = 0;

      const arrayResult = [];

      for (const index in nums) {
        for (const elem in nums) {
          if (nums[index] + nums[elem] === target && elem !== index) {
            result2 = index;
            result1 = elem;
          }
        }
      }
      arrayResult.push(parseInt(result1), parseInt(result2));

      return arrayResult;
    }

    // twoSum([1, 4, 5], 5);

    //==================================================================================

    //6 kyu Array Diff

    // Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

    // It should remove all values from list a, which are present in list b keeping their order.

    // arrayDiff([1,2],[1]) == [2]

    // If a value is present in b, all of its occurrences must be removed from the other:

    // arrayDiff([1,2,2,2,3],[2]) == [1,3]

    function arrayDiff(a, b) {
      const result = [];
      for (let aItem of a) if (!b.includes(aItem)) result.push(aItem);
      return result;
    }

    // arrayDiff([1], [2]);

    //==================================================================================

    // 6 kyu
    // Bit Counting

    // Write a function that takes an integer as input, and returns the number of bits that are equal to
    // one in the binary representation of that number. You can guarantee that input is non-negative.

    // Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case

    const countBits = function (n) {
      const nBinary = n.toString(2);
      const nArray = nBinary.split("");
      const nArrayInt = nArray.map(function (x) {
        return parseInt(x, 10);
      });
      const sum = nArrayInt.reduce((acc, current) => acc + current, 0);
      return sum;
    };

    countBits(6523184790);

    // 5 kyu
    //  Moving Zeros To The End

    // Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.

    // moveZeros([false,1,0,1,2,0,1,3,"a"]) // returns[false,1,1,2,1,3,"a",0,0]

    function moveZeros(arr) {
      let zeroIndexes = [];
      for (let index in arr) {
        if (arr[index] === 0) zeroIndexes.push(index);
      }
      const zeroIndexesReversed = zeroIndexes.reverse();
      for (let index of zeroIndexesReversed) {
        arr.splice(index, 1);
      }

      zeroIndexes.forEach(() => arr.push(0));
      return arr;
    }

    // moveZeros([false, 1, 0, 1, 2, 0, 1, 3, "a"]);
    console.log(
      moveZeros([9, 0, 0, 9, 1, 2, 0, 1, 0, 1, 0, 3, 0, 1, 9, 0, 0, 0, 0, 9])
    );

    //==================================================================================
    // 5 kyu
    // Simple Pig Latin

    // Move the first letter of each word to the end of it, then add "ay" to the end of the word. Leave punctuation marks untouched.
    // Examples

    // pigIt('Pig latin is cool'); // igPay atinlay siay oolcay
    // pigIt('Hello world !');     // elloHay orldway !

    function pigIt(str) {
      const splitted2 = [];
      str.split(" ").forEach((word) => {
        if (!word.match(/[!.?]/g))
          splitted2.push(word.substring(1) + word.substring(0, 1) + "ay");
        else splitted2.push(word);
      });
      return splitted2.join(" ");
    }
    pigIt("Quis custodiet ipsos custodes ?");

    //==================================================================================
    // 7 kyu
    // Vowel Count

    // Return the number (count) of vowels in the given string.

    // We will consider a, e, i, o, u as vowels for this Kata (but not y).

    // The input string will only consist of lower case letters and/or spaces.

    function getCount(str) {
      return str.split("").filter((char) => char.match(/[aeiou]/)).length;
    }

    // getCount("abracadabra");

    // 5 kyu
    // Valid Parentheses

    // Write a function that takes a string of parentheses, and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.
    // Examples

    // "()"              =>  true
    // ")(()))"          =>  false
    // "("               =>  false
    // "(())((()())())"  =>  true

    // Constraints

    // 0 <= input.length <= 100

    function validParentheses(str) {
      let x = 0;
      for (let item of str.split("")) {
        if (item === "(") x++;
        else if (item === ")") x--;
        if (x < 0) break;
      }
      return x === 0 ? true : false;
    }

    validParentheses("((");
  </script>
</head>
